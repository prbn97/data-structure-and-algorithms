# Linked List

### Linked List vs Arrays.
Let's compare linked lists with arrays. 
>It just depends what you're going to be using your data structure for...


| Operation           | Linked Lists | Arrays   |
|---------------------|--------------|----------|
| Push                | O(1)         | O(1)     |
| Pop                 | <span style="background-color:red">O(n)</span> | <span style="background-color:green">O(1)</span>  |
| Shift               | <span style="background-color:green">O(1)</span> | <span style="background-color:red">O(n)</span>  |
| Unshift             | <span style="background-color:green">O(1)</span> | <span style="background-color:red">O(n)</span>  |
| Insert              | O(n)         | O(n)     |
| Delete              | O(n)         | O(n)     |
| Lookup by Index     | <span style="background-color:red">O(n)</span> | <span style="background-color:green">O(1)</span>  |
| Lookup by Value     | O(n)         | O(n)     |


## Linked List are made of **_Nodes_**...
```mermaid
---
title: Linked List 
---
classDiagram
    direction LR
    
    class 23{
    }
    class 35{
    }
    class 41{
    }


    head "*ptr"-->  23
    tail "*ptr"-->  41

    23 "*ptr"--> 35
    35 "*ptr"--> 41
    41 "*ptr"--> null
```

### ...nodes are mades up of **_value_** and **_*pointer_**.

```mermaid
---
title: Node
---
classDiagram
    direction LR
    
    class Value{
        *pointer
    }
    class value{
        *pointer
    }
    Value --> value
    value --* value : null

```   

    So this node is actually an object.
    That looks something like this

```js
    {
        value: int
        *next: null
    }

```



Linked list looks something like this...

```mermaid

classDiagram
    direction LR
    
    class 23{
    }
    class 35{
    }
    class 41{
    }


    head -->  23
    tail -->  41

    23 "*next"--> 35
    35 "*next"--> 41
    41 "*next"--> null
```

```js
    {
        head: {
                value: 23
                *next: {
                        value: 35
                        *next: {
        tail: ----------------> value: 41
                                *next: null
                            }
                    }
            }
    }
```

## Class LinkedList and Class Node
Create a LinkedList class and Node class (to rewrite code).

### constructor(value) {...}
The constructor has a couple of things in common with the other methods of that linked list.

```js
class LinkedList {
    constructor(value) {
        // create new Node
    }
    push(value) {
        // create new Node
        // add Node to end
    }
    unshift(value) {
        // create new Node
        // add Node to beginning
    }
    insert(index, value) {
        // create new Node
        // insert Node
    }
}
```
constructor and the other methods each get passed a argument "value" and create a new Node.

    we don't want to rewrite this code for different times in each one of these methods.

    So we're going to create a separate class for creating nodes.

```js
class Node {
    constructor(value) {
        this.value = value
        this.next = null
    }
}

// to create a node
const newNode = new Node(0)

class LinkedList {
    constructor(value) {
        const newNode = new Node(value)
        this.head = newNode
        this.tail = this.head
        this.length = 1
    }
}

let myLinkedList = new LinkedList(5)
```
---

### method - push(value) {...}
 
push(value): Places an element on top of the stack

    Start out with our edge case first... when we try to add(push) a node on the list

```mermaid
---
title: when we push(value) a node for the first time..
---
classDiagram
    direction LR

    note for 4 "myLinkedList.push(4)"

    4 "*ptr"-->  Null
    
    head "*ptr"-->  null
    tail "*ptr"-->  null
    
```
    but head and tail pointing to null...

```mermaid
---
title: We make head and tail pointing to the new node
---
classDiagram
    direction LR
    note for 4 "myLinkedList.push(4)"
    head "*ptr"-->  4
    tail "*ptr"-->  4
    4 "*ptr"-->  Null
    
    
```
```js
    if (!this.head){
            this.head = newNode
            this.tail = newNode
            } 
```

```mermaid
---
title: pushing a node in the list
---
classDiagram
    direction LR
    
    head "*ptr"-->  2
    tail "*ptr"-->  7

    2 "*ptr"--> 5
    5 "*ptr"--> 11
    11 "*ptr"--> 1
    1 "*ptr"--> 7
    7 "*ptr"--> null

```



```js
 push(value){ // Places an element on the linked list the tail
    const newNode = new Node(value)
    if (!this.head){
        this.head = newNode
        this.tail = newNode
    } else {
        this.tail.next = newNode
        this.tail = newNode
    }
    this.length++
    return this
 }
```

## method - pop() {...} 
 
We're just going to:
1. remove the item from the end.
2. move tail over to the previous item
3. return the item that we removed.

```mermaid
---
title: poping a node of the list
---
classDiagram
    direction LR
    note for tail "myLinkedList.pop()"
    head "*ptr"-->  2
    tail "*ptr"-->  7

    2 "*ptr"--> 5
    5 "*ptr"--> 11
    11 "*ptr"--> 1
    1 "*ptr"--> 7
    7 "*ptr"--> null

```
---
```mermaid
classDiagram
    direction LR
    note for tail "myLinkedList.pop()"
    head "*ptr"-->  2
    tail "*ptr"-->  1

    2 "*ptr"--> 5
    5 "*ptr"--> 11
    11 "*ptr"--> 1
    1 "*ptr"--> 7
    7 "*ptr"--> null
```
---
```mermaid
classDiagram
    direction LR
    head "*ptr"-->  2
    tail "*ptr"-->  1
    2 "*ptr"--> 5
    5 "*ptr"--> 11
    11 "*ptr"--> 1
    1 "*ptr"--> null
    note for 7 "myLinkedList.pop()"
    class 7 {

    }
```
### So we do have a couple of edge cases...
    
    Edge case #1: a linked list that don't have any items in it.
    (we can't pop something from this linked list).

```mermaid
classDiagram
    direction TB
    
    head "*ptr"-->  null
    tail "*ptr"-->  null
    
```

    Edge case #2: if we have a list with one item.
```mermaid
classDiagram
    direction LR
    
    head "*ptr"-->  4
    tail "*ptr"-->  4
    4 "*ptr"-->  nill
    
```
    Edge case #3: if we have a list with some items in it
```mermaid
classDiagram
    direction LR

    4 "*ptr"-->  7
    7 "*ptr"-->  2
    2 "*ptr"-->  5
    head "*ptr"-->  4
    5 "*ptr"-->  null
    tail "*ptr"-->  5
    
```

### How we do track the node before the end??!!
    we going to do this is with two variables, temp and pre.
```mermaid
classDiagram
    direction LR
    
    11 "*ptr"-->  3
    3 "*ptr"-->  23
    23 "*ptr"-->  7
    7 "*ptr"-->  4
    4 "*ptr"-->  null
    temp "*ptr"-->  11
    pre "*ptr"-->  11
    tail "*ptr"-->  4
    head "*ptr"-->  11
    
```
    Temp is going to be the variable that once we iterate through this list is going to be pointing to that last item, that we return.
    
    Pre is going to point to the item that is next to last.

```mermaid
classDiagram
    direction LR

    temp "*ptr"-->  4
    note for 4 "last item"

    11 "*ptr"-->  3
    3 "*ptr"-->  23
    23 "*ptr"-->  7
    7 "*ptr"-->  4
    4 "*ptr"-->  null

    pre "*ptr"-->  7
    note for 7 "next to the"

    head "*ptr"-->  11
    
```
    We're going to say that tail is equal to pre.
    (pre is used only to set tail.)
---
```mermaid
classDiagram
    direction LR
    head "*ptr"-->  11

    tail "*ptr"-->  7
    pre "*ptr"-->  7

    11 "*ptr"-->  3
    3 "*ptr"-->  23
    23 "*ptr"-->  7
    7 "*ptr"-->  4
    4 "*ptr"-->  null
    note for 4 "last item"
    
```
---
    Then we say tail.next = null, which removes that last item.

```mermaid
classDiagram
    direction LR
    head "*ptr"-->  11

    tail "*ptr"-->  7

    11 "*ptr"-->  3
    3 "*ptr"-->  23
    23 "*ptr"-->  7
    7 "*ptr"-->  null
    4 "*ptr"-->  Null
    temp "*ptr"-->  4
```
---
    And bring the temp variable back to finish the pop method
```mermaid
classDiagram
    direction LR
    temp "*ptr"-->  4
    4 "*ptr"-->  Null
```


```js
 pop() {
    if (!this.head) return undefined // Edge case #1
    // Edge case #2
    let temp = this.head
    let pre = this.head
    // Edge case #3
    while (temp.next) {
        pre = temp
        temp = temp.next
        }
    this.tail = pre
    this.tail.next = null
    this.length--
    if (this.length === 0){
        this.head = null
        this.tail = null
        }
    return temp
}
```

## method - unshift(){...}



## method - shift(){...}

## method - get(){...}

## method - set(){...}

## method - insert(){...}

## method - remove(){...}

## method - reverse(){...}







```js

class Node {
    constructor(value) {
        this.value = value
        this.next = null
    }
}

class LinkedList {
    constructor(value) {
        const newNode = new Node(value)
        this.head = newNode
        this.tail = this.head
        this.length = 1
    } 
    push(value){
        const newNode = new Node(value)
        if (!this.head){
            this.head = newNode
            this.tail = newNode
            } else {
            this.tail.next = newNode
        this.tail = newNode
            }
        this.length++
        return this
    }
    pop() {
        if (!this.head) return undefined
        let temp = this.head
        let pre = this.head
        while (temp.next) {
            pre = temp
            temp = temp.next
            }
        this.tail = pre
        this.tail.next = null
        this.length--
        if (this.length === 0){
            this.head = null
            this.tail = null
            }
        return temp
    }
    
}

let myLinkedList = new LinkedList(5)
```